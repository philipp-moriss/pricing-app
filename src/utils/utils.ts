import { SelectChangeEvent } from '@mui/material/Select/SelectInput';import { ChangeEvent, useEffect, useRef, useState } from 'react';export const dateFormat = (date: Date): string => {	return date.toLocaleDateString('az-Cyrl-AZ');};export const getDateFormatTime = (date: Date): string => {	return date.toLocaleTimeString('en-US');};export const convertToDate = (dateString: string): Date => {	return new Date(dateString);};export const validateEmail = (email: string | null): boolean => {	const regex = new RegExp('[a-z0-9]+@[a-z]+.[a-z]{2,3}');	return regex.test(email ? email.toLowerCase() : '');};type UseInputReturnType = {	value: string | null;	onChange: (e: any) => void;	onBlur: (e: FocusEvent) => void;	isDirty: boolean;	valid: UseValidationReturnType;	initValue: string | number;	setValue: (value: string | null) => void;};export const useInput = (	initValue: string | number,	validations: { isEmpty?: boolean; minLength?: number; maxLength?: number; isEmail?: boolean },): UseInputReturnType => {	const [isDirty, setDirty] = useState(false);	const [value, setValue] = useState<string | null>('');	const valid = useValidation(value, validations);	const onChange = (e: any): void => {		if (e.currentTarget) {			setValue(e.currentTarget.value);		} else if (e.target) {			setValue(e.target.value);		}	};	const onBlur = (e: FocusEvent): void => {		setDirty(true);	};	return {		value,		initValue,		onChange,		onBlur,		isDirty,		valid,		setValue,	};};type UseValidationReturnType = {	isEmpty: boolean;	minLengthError: boolean;	emailError: boolean;	maxLengthError: boolean;	inputValid: boolean;};export const useValidation = (	value: string | null,	validations: { isEmpty?: boolean; minLength?: number; maxLength?: number; isEmail?: boolean },): UseValidationReturnType => {	const [isEmpty, setEmpty] = useState(true);	const [minLengthError, setMinLengthError] = useState(false);	const [maxLengthError, setMaxLengthError] = useState(false);	const [emailError, setEmailError] = useState(false);	const [inputValid, setInputValid] = useState(false);	useEffect(() => {		for (const validation in validations) {			switch (validation) {				case 'minLength': {					// eslint-disable-next-line @typescript-eslint/ban-ts-comment					// @ts-ignore					value.length < validations[validation]						? setMinLengthError(true)						: setMinLengthError(false);					break;				}				case 'maxLength': {					// eslint-disable-next-line @typescript-eslint/ban-ts-comment					// @ts-ignore					value.length < validations[validation]						? setMaxLengthError(true)						: setMaxLengthError(false);					break;				}				case 'isEmpty': {					if (value === null) {						setEmpty(false);					} else {						value ? setEmpty(false) : setEmpty(true);					}					break;				}				case 'isEmail': {					validateEmail(value) ? setEmailError(false) : setEmailError(true);					break;				}			}		}	}, [value]);	useEffect(() => {		if (isEmpty || maxLengthError || minLengthError || emailError) {			setInputValid(false);		} else {			setInputValid(true);		}	}, [isEmpty, minLengthError, maxLengthError, emailError]);	return {		isEmpty,		minLengthError,		emailError,		maxLengthError,		inputValid,	};};export const usePrevious = <T>(value: T): T => {	const ref: any = useRef<T>();	// Store current value in ref	useEffect(() => {		ref.current = value;	}, [value]);	return ref.current;};